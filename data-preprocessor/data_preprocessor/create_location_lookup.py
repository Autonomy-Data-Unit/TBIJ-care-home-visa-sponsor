# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_create_location_lookup.ipynb.

# %% auto 0
__all__ = ['lon_lat_lookup_path', 'df_worldcities', 'admin_lon_lats', 'df_sponsors', 'client', 'places_corrections_path',
           'places', 'api_key', 'gmaps', 'place_merc_lookup', 'place_merc_lookup_path', 'xs', 'ys', 'correct_placename',
           'lat_lng_to_mercator']

# %% ../nbs/00_create_location_lookup.ipynb 4
import warnings
import pandas as pd
from pandas.errors import DtypeWarning
from pathlib import Path
import json
import numpy as np
import time
import redis
from geopy.geocoders import Nominatim
from openai import OpenAI
import math
import geopy
import googlemaps
import os

from . import const

# %% ../nbs/00_create_location_lookup.ipynb 6
lon_lat_lookup_path = Path(const.output_path, "lon_lat_lookup.json")
if lon_lat_lookup_path.is_file():
    with open(lon_lat_lookup_path, "r") as f:
        place_lon_lat_lookup = json.loads(f.read())
else:
    place_lon_lat_lookup = {}

# %% ../nbs/00_create_location_lookup.ipynb 8
df_worldcities = pd.read_csv(Path(const.data_path, 'worldcities.csv'))

# Filter to UK
df_worldcities = df_worldcities[df_worldcities['country'] == 'United Kingdom']

# Add cities

for i, row in df_worldcities.iterrows():
    place = row['city'].strip().lower()
    place_lon_lat_lookup[place] = { 'lat' : row['lat'], 'lng' : row['lng'] }
    
# Add administration areas, by averaging

admin_lon_lats = {}
for i, row in df_worldcities.iterrows():
    if pd.isna(row['admin_name']):
        continue

    if (row['city'].strip().lower() == row['admin_name'].strip().lower()) or \
        (row['admin_name'].strip().lower() == f"{row['city'].strip()}, City of".strip().lower()):
        place = row['city']
    else:
        place = f"{row['city'].strip()}, {row['admin_name'].strip()}".strip().lower()
    
    if place in place_lon_lat_lookup:
        continue
    if not place in admin_lon_lats:
        admin_lon_lats[place] = []
    admin_lon_lats[place].append( (row['lat'], row['lng']) )
    
# average the administration areas

for k,vs in admin_lon_lats.items():
    place_lon_lat_lookup[k] = {
        'lat' : sum(map(lambda e: e[0], vs)) / len(vs),
        'lng' : sum(map(lambda e: e[1], vs))  / len(vs),
    }

# %% ../nbs/00_create_location_lookup.ipynb 10
df_sponsors = pd.read_csv(Path(const.data_path, "all-skilled-home-care-sponsors.csv"))
df_sponsors.head()

# %% ../nbs/00_create_location_lookup.ipynb 11
client = OpenAI()

def correct_placename(placename):
    system_context = (
        "Given a mispelled version of a UK placename, you output either of the following: "
        "If you think it is a mispelled version of a UK placename, you output the corrected version. "
        "If you think string does not refer to a place, you output 'INVALID'."
    )
   
    response = client.chat.completions.create(
        model="gpt-4-turbo",
        messages=[
            {"role": "system", "content": system_context},
            {"role": "user", "content": placename},
        ]
    )
    
    return response.choices[0].message.content

# %% ../nbs/00_create_location_lookup.ipynb 13
places_corrections_path = Path(const.output_path, "places_corrections.json")
if places_corrections_path.is_file():
    with open(places_corrections_path, "r") as f:
        places_corrections = json.loads(f.read())
else:
    places_corrections = {}

# %% ../nbs/00_create_location_lookup.ipynb 14
df_sponsors = pd.read_csv(Path(const.data_path, "all-skilled-home-care-sponsors.csv"))
df_sponsors['Town/City'] = df_sponsors['Town/City'].str.lower().str.strip()

places = []

for i, row in df_sponsors.iterrows():
    if pd.isna(row['County']):
        places.append(row['Town/City'].lower().strip())
    elif pd.isna(row['Town/City']):
        places.append(row['County'].lower().strip())
    else:
        places.append(f"{row['Town/City'].strip()}, {row['County'].strip()}".lower())
        
places = set(places)

# %% ../nbs/00_create_location_lookup.ipynb 15
api_key = os.environ.get('GOOGLE_MAPS_API_KEY')
gmaps = googlemaps.Client(key=api_key)

places = places - set(place_lon_lat_lookup.keys())
places = places - set(places_corrections.keys())

for i, place in enumerate(places):
    print(f"{i+1}/{len(places)}", end='\r')
    
    success = False
    while not success:
        if place in place_lon_lat_lookup or place in places_corrections:
            continue

        result = gmaps.geocode(f"{place.title()}, UK")
        location = result[0]['geometry']['location']
        
        if not location:
            place_corrected = correct_placename(place).lower()
            result = gmaps.geocode(f"{place_corrected.title()}, UK")
            location = result[0]['geometry']['location']
            print(f"{place} -> {place_corrected}")
            if location: places_corrections[place] = place_corrected
        else:
            place_corrected = place
        
        if location:
            place_lon_lat_lookup[place_corrected] = { 'lat' : location['lat'], 'lng' : location['lng'] }
        else:
            print(f"  {place} still invalid")
            place_lon_lat_lookup[place_corrected] = "invalid"
            
        success = True

# %% ../nbs/00_create_location_lookup.ipynb 16
"""
geolocator = Nominatim(user_agent="Alex Guli")

places = places - set(place_lon_lat_lookup.keys())
places = places - set(places_corrections.keys())

for i, place in enumerate(places):
    print(f"{i+1}/{len(places)}", end='\r')
    
    success = False
    while not success:
        try:
            if place in place_lon_lat_lookup or place in places_corrections:
                continue

            location = geolocator.geocode(f"{place.title()}, UK")
            
            if location is None:
                place_corrected = correct_placename(place).lower()
                location = geolocator.geocode(f"{place_corrected.title()}, UK")
                print(f"{place} -> {place_corrected}")
                if location is not None: places_corrections[place] = place_corrected
            else:
                place_corrected = place
            
            if location is not None:
                place_lon_lat_lookup[place_corrected] = { 'lat' : location.latitude, 'lng' : location.longitude }
            else:
                print(f"  {place} still invalid")
                place_lon_lat_lookup[place_corrected] = "invalid"
                
            success = True
        except geopy.exc.GeocoderUnavailable as e:
            print("\nFailed API")
            time.sleep(30)
"""

# %% ../nbs/00_create_location_lookup.ipynb 19
with open(lon_lat_lookup_path, 'w') as f:
    json.dump(place_lon_lat_lookup, f)
    
with open(places_corrections_path, 'w') as f:
    json.dump(places_corrections, f)

# %% ../nbs/00_create_location_lookup.ipynb 20
def lat_lng_to_mercator(lat, lng):
    r_major = 6378137.000
    x = r_major * math.radians(lng)
    scale = x/lng
    y = 180.0/math.pi * math.log(math.tan(math.pi/4.0 + 
        lat * (math.pi/180.0)/2.0)) * scale
    return (x, y)

# %% ../nbs/00_create_location_lookup.ipynb 21
place_merc_lookup = { place : lat_lng_to_mercator(loc['lat'], loc['lng']) for place, loc in place_lon_lat_lookup.items() }    
place_merc_lookup_path = Path(const.output_path, "place_merc_lookup.json")
with open(place_merc_lookup_path, 'w') as f:
    json.dump(place_merc_lookup, f)

# %% ../nbs/00_create_location_lookup.ipynb 24
df_sponsors = pd.read_csv(Path(const.data_path, "current-skilled-home-care-sponsors.csv"))
df_sponsors['Town/City'] = df_sponsors['Town/City'].str.lower().str.strip()
df_sponsors['Town/City'] = df_sponsors['Town/City'].replace(places_corrections)
df_sponsors.head()

# %% ../nbs/00_create_location_lookup.ipynb 25
xs, ys = [], []

for i, row in df_sponsors.iterrows():
    if pd.isna(row['County']):
        place = row['Town/City'].lower().strip()
    elif pd.isna(row['Town/City']):
        place = row['County'].lower().strip()
    else:
        place = f"{row['Town/City'].strip()}, {row['County'].strip()}".lower()
    
    if place in place_lon_lat_lookup:
        x, y = place_merc_lookup[place]
        xs.append(x)
        ys.append(y)
    else:
        print(place)
        xs.append(-1)
        ys.append(-1)

# %% ../nbs/00_create_location_lookup.ipynb 26
df_sponsors['merc_x'] = xs
df_sponsors['merc_y'] = ys

df_sponsors.to_csv(Path(const.output_path, "current-skilled-home-care-sponsors-with-loc.csv"), index=False)
